var i;

proc p1(){
  while (i!=4){
    i = i + 1 
  }
};

proc p2(){
  while (i!=0){
    i = i - 1 
  }
};

init{
  i = 2;
  p1()||p2()
}

check{
  Vz.(!(i==5) ^ []:z)
}


{-

(i==0 & i==2')|
(i==2 & i==3') | (i==2 & i==1') |
(i==3 & i==4') | (i==3 & i==2') | (i==1 & i==0') | (i==1 & i==2') |
(i==4 & i==4') | (i==4 & i==3') | ((i==2 & i==3') | (i==2 & i==1'))x2 | (i==0 & i==1') | (i==0 & i==0') |
((i==3 & i==4') | (i==3 & i==2'))x3 | ((i==1 & i==2') | (i==1 & i==0'))x3 |
((i==4 & i==4') | (i==4 & i==3'))x3 | ((i==2 & i==3') | (i==2 & i==1'))x6 | ((i==0 & i==0') | (i==0 & i==1'))x3
etc

-Un comando representa una transici√≥n.
-En cada paso de la construccion del BDD se agregan tantas transiciones como procesos se esten evaluando concurrentemente.
-Para calcular las transiciones del paso actual necesito saber cuales eran las del paso anterior unicamente.
-El BDD se termina de contruir una vez que no haya mas transiciones que agregar (init termino de evaluarse).

-}
