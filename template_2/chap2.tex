%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Conceptos preliminares}

La verificación de modelos o model checking es una técnica automática de verificación de propiedades sobre sistemas con una cantidad finita de estados. Es una alternativa interesante con respecto al testing o las simulaciones ya que a diferencia de estas técnicas, el model checking hace una prueba exhaustiva del sistema, es decir, analiza todas las trazas posibles de la ejecución del sistema en cuestión. Sin embargo, esto trae un problema, esto es el problema de la explosión de estados. Esto ocurre en sistemas con muchas interacciones internas, y que pueden hacer crecer exponencialmente el espacio de estados posibles del sistema, ya que la prueba es exhaustiva no se puede ignorar ningún estado posible.
En los últimos años se ha logrado un gran progreso en cómo lidiar con este problema mediante formas más compactas de representar al sistema, como por ejemplo, una representación simbólica.

El proceso del model checking consta de varias tareas:

Modelado: Lo primero es convertir el modelo de un sistema en un formalismo aceptado por la herramienta de verificación de modelos.

Especificación: Es necesario expresar de alguna forma las propiedades que necesitan ser verificadas en el modelo. En general estas propiedades se dan en alguna lógica formal, particularmente lógicas temporales ya que estas pueden expresar comportamientos futuros del sistema.

Verificación: Dado el modelo y la especificación, la tarea de verificar significa explorar exhaustivamente todos los estados posibles del sistema para llegar a la conclusión de que el mismo satisface la especificación o no, en este último caso se suele dar también una traza de error, lo cual ayuda al programador para encontrar fallas en el sistema. Sin embargo, la causa de que el modelo no haya pasado la verificación puede deberse a una especificación incorrecta.


\section{Modelado de sistemas}
En esta sección veremos cómo representar un modelo explícitamente mediante una estructura de Kripke, más tarde veremos otra forma de representación llamada simbólica que representa el modelo mediante una fórmula lógica de primer orden.

Sea $AP$ un conjunto de proposiciones atómicas, una estructura de Kripke $M$ sobre $AP$ es una cuatro-upla $M = (S, S_{0}, R, L)$ donde
\newline1. $S$ es un conjunto finito de estados.
\newline2. $S_{0} \in S$ es el conjunto de estados iniciales.
\newline3. $R \in S \times S$ es una relación de transición total, es decir para cada estado $s \in S$ existe un estado $s' \in S$ tal que $R(s,s')$ vale.
\newline4. $L \colon S \to 2^{AP}$ es una función que etiqueta a cada estado con el conjunto de proposiciones atómicas que son verdaderas en ese estado.
Un camino en la estructura $M$ desde un estado $s$ es una secuencia infinita de estados $p = s_{0}, s_{1}, s_{2}, s_{3}, ...$, tal que $s = s_{0}$ y $R(s_{i},s_{i+1})$ vale para todo $i>0$.

Sea $V = {v_{1}, v_{2}, ..., v_{n}}$ el conjunto de variables del sistema y sea $D$ el dominio, llamaremos una valuación de $V$ a una función que asocia a cada variable de $V$ un valor de $D$.

Un estado del sistema se puede representar como una valuación de las variables del sistema. Una proposición atómica de la forma $v = d$ donde $v \in V$ y $d \in D$ será verdadera en un estado $s$ si y solo si $s(v) = d$.
Dada una valuación, podemos escribir una fórmula que sea verdadera precisamente para esa valuación, por ejemplo si tenemos $V = \{x,y,z\}$ y la valuación $(x \gets True, y \gets True, z \gets False)$ entonces derivamos la fórmula $(x \land y \land !z)$. En general, una fórmula puede ser verdadera para varias valuaciones. Si adoptamos la convención de que una fórmula representa el conjunto de todas las valuaciones que la hacen verdadera, entonces podremos describir ciertos conjuntos de estados como fórmulas de primer orden.
En particular, el conjunto de los estados iniciales del sistema puede describirse como una fórmula de primer orden $S_{0}$ sobre las variables en $V$.
Una transición del sistema se puede representar como un par ordenado de valuaciones, de forma similar podemos describir conjuntos de transiciones mediante una formula para ese par, pero para poder expresar la fórmula se necesita una copia $V'$ de $V$ para hablar del \emph siguiente estado, en V' todas las variables estan primadas. Por ejemplo si tenemos una transición $(x \gets True, y \gets True, z \gets False,(x \gets True, y \gets True, z \gets True))$, podemos derivar la fórmula $(x \land y \land !z \land x' \land y' \land z')$.

Consideremos el siguiente ejemplo, tenemos $V = \{x,y,z\}$ y $D = \{True, False\}$, $S_{0} (x,y,z) = (x= True \land y = True \land z = False)$, y tenemos solo una transición: $z := x \land y$, definimos la estructura de kripke de la siguiente manera:

\[S = D \times D \times D\]
\[S_{0} = \{(1, 1, 0)\}\]
\[R = \{((1, 1, 0), (1, 1, 1)), ((1, 1, 1), (1, 1, 1))\}\]
\[L (1, 1, 0) = \{x = 1, y = 1, z = 0\},\]
\[L (1, 1, 1) = \{x = 1, y = 1, z = 1\}\]

El único camino posible en esta estructura partiendo del estado inicial es: (1, 1, 0), (1, 1, 1), (1, 1, 1), (1, 1, 1) …

\section{Especificación de propiedades}

Ahora describiremos una lógica para especificar propiedades deseadas en una estructura de Kripke u otra máquina de transición de estados. La lógica utiliza proposiciones atómicas y operadores como la disyunción y la negación para construir expresiones más complicadas que describan propiedades sobre estados.
La lógica temporal es un formalismo que permite describir secuencias de transiciones entre estados en un sistema reactivo, nos interesa saber si en algún momento se llega a un estado determinado o que nunca se llegue a un deadlock. Para esto introduce nuevos operadores especiales que permiten hablar sobre tiempo. Estos operadores pueden combinarse con los operadores lógicos conocidos.
Analizaremos a continuación una lógica temporal muy potente llamada Cálculo-$\mu$.


\section{Cálculo-$\mu$}

Sea $M = (S, T, L)$ una estructura de Kripke y sea $VAR = {Q, Q1, Q2, …}$ un conjunto de variables relacionales, donde a cada variable relacional se le puede asignar un subconjunto de S, construimos una $\mu$-fórmula como sigue:

-Si $p$ pertenece a $AP$ entonces $p$ es una fórmula.
-Si $Q$ pertenece a $VAR$, $Q$ es una fórmula.
-Si $f$ y $g$ son fórmulas, entonces $\neg f$, $f \lor g$, y $f \land g$ son fórmulas.
-Si $f$ es una fórmula, entonces $\Box f$ y $\Diamond f$ son fórmulas.
-Si $Q \in VAR$ y $f$ es una fórmula entonces $\mu Q.f$ y $\nu Q.f$ son fórmulas

Las variables pueden estar libres o ligadas en una fórmula a través de un operador de punto fijo. Una fórmula cerrada es una fórmula sin variables libres.

El significado intuitivo de $\Diamond f$ es “Es posible realizar una transición a un estado donde f vale“, similarmente $\Box f$ significa “f vale en todos los estados alcanzables por medio de una transición“
Los operadores $\mu$ y $\nu$ expresan puntos fijos menores y mayores respectivamente. El conjunto vacío de estados se denota con $False$ y el conjunto de todos los estados $S$ se denota con $True$.

Ejemplos

-$\nu Z \cdot f \land \Box Z$ se interpreta como “f es verdadera siempre en todo camino”
-$\mu Z \cdot f \lor \Diamond Z$ se interpreta como “existe un camino hacia un estado donde f vale”
-$\nu Z \cdot \Diamond T \land \Box Z$ se interpreta como “no hay estados que no tengan transiciones hacia otros estados”

Formalmente, una fórmula $f$ se interpreta como un conjunto de estados donde $f$ es verdadera, escribimos este conjunto como $[[f]]$ sobre un sistema de transición de estados $M$ y un ambiente $e: VAR \to 2^{S}$, denotaremos $e[Q \gets W]$ como un ambiente que es igual a $e$ solo que $Q$ ahora tiene el valor $W$. el conjunto $[[f]]$ sobre $M$ y $e$ se define recursivamente de la siguiente manera:

\[ [[p]] M e = \{s \mid p \in a L(s)\} \] 
\[ [[Q]] M e = e(Q) \]
\[ [[\neg f]] M e = S \setminus [[f]] M e \]
\[ [[f \land g]] M e = [[f]] M e \cap [[g]] M e \]
\[ [[f \lor g]] M e = [[f]] M e \cup [[g]] M e \]
\[ [[\Diamond f]] M e = \{s \mid \exists t : s \to t \land t \in [[f]] M e\} \]
\[ [[\Box f]] M e = \{s \mid \forall t : s \to t  \rightarrow t \in [[f]] M e\} \]
$[[[\mu Q f]] M e$ es el menor punto fijo del predicado transformador $t:2^{S} \to 2^{S}$ definido como $t(W) = [[f]] M e[Q \gets W] $
$ [[\nu Q f]] M e$ es el mayor punto fijo del predicado transformador $t:2^{S} \to 2^{S}$ definido como $t(W) = [[f]] M e[Q \gets W] $
